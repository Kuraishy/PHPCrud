
- se crea un public folder con el index
- se crea el helpers.php y la funcion para obtener el basepath absoluto (__DIR__)

- en el index.php se importa el archivo helpers.php y llama al
home.view.php.
- se separa el home.view.php en varias partials y son llamadas
desde el home.view.php con las funciones del helper (basePath)
debido a que el home.view.php es llamado desde index.php. este archivo hereda todo lo llamado desde index.php por lo que importar
el archivo helpers.php ya no es necesario

-se crea el helper loadview para cargar la vie mas rapdio
    - se usa loadView() y ya no se necesita el require porque el requiere es llamado
    dentro de la funcion loadView() 

-se crea el helper loadPartials() con su checador si existe el archivo
-se crea el helper inspect() que muestra la variable dentro de <pre></pre>
-se crea el helper inspectAndDie() lo mismo que arriba pero tien die(var_dump(..))

////ROUTERS/////

- se crea el .htacess con sus datos.
- en index se crea el array de routes
- con array_key_exists se checa que $_SERVER["REQUEST_URI"] exista en los routes
    -si existe se executa el require basepath(controller.php)
    -sino se executa el require basepath(404.php)

- en el controller.php se carga el loadview() se la vista
    -index.php -> usando el array se routes se llama al
    controlador ("/"->home.controller.php)
    -home.controller.php -> se loadView(home.view.php)
    -home.view.php -> muestra el html

- se crean las views usando los partials

- se exporta el router y routes a otro archivo en el root
    -routes.php -> return ['/' => 'controllers/home.php', //devuelve el arreglo de routes

    -router.php -> (importa los routes y checa)
        //importando routes
        $routes = require basePath("routes.php");
        if (array_key_exists($uri, $routes)) {
            // echo "true";
            require(basePath($routes[$uri]));
        } else {
            http_response_code(404);
            require(basePath($routes['404']));
        }

    -index.php ->  obtiene el request uri y lo envia al router.php
        //obtiene el uri
        $uri = $_SERVER['REQUEST_URI'];
        //usando enviando $uri al router
        require basePath("router.php");

//refaactor to class

- se crea la clase router en Router
    -array de routes
    -funcion para agrgar routes como map [method, uri, controller]
    -funciones get,post para agregar routes
    -funcion route() que recive uri y metodo y loopea en el array para encontrar la direccion
         if ($route['uri'] === $uri && $route['method'] === $method) {
                require basePath($route['controller']);
                return;
            }
    - sale del script exit;
- se importa el router y routes en index.php
    
    require basePath('Router.php'); //importando router class
    $router = new Router();
    $routes = require basePath('routes.php'); //importando las rutas
    $uri = $_SERVER['REQUEST_URI'];//obtencion de uri
    $method = $_SERVER['REQUEST_METHOD'];//obtencion metodo
    //pasando checando si existe el uri y metodo
    $router->route($uri, $method);`

-se associan las routes con sus metodos y controladores en routes.php
    -se borra el array anterior
    //asociando metodo y uri al router
    $router->get('/uri', 'controllers/listings.php');

-crear database class conection with PDO
    -recibe un mapa de config en el constructor
        [host,port,dbname,username,password]
        -se activa la opcion ATTR_ERROMDOE=>ERRMODE_EXCEPTION,PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC, //para recibir mapa $listing['columna']
        -se conecta mediante un try and catch 
            try-> conn = new PDO(dsn,confi..,option);
            catch-> PDOexecption $e ->getMessage()
    -para recibir como clase 
         $options = [
            PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
            //no numeric index
            PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_OBJ,
        ];

    pasa a 


-se crea el folder config donde esta un archivo db.php
    se debe usar el nombre del contenedor
    return [
    //'host' => '127.0.0.1',
    'host' => 'database', //using docker container name
    'port' => 3306,
    'dbname' => 'php_database',return ['host' => 'localhost','port' => 3306,..]

-se importa el db class despues de importar el router class en index.php

-Query method
    -adding query method in db class
     public function query($query, $params = [])
        try 
            //creating statemnet
            $stmt = $this->conn->prepare($query);
            //bind named params
            foreach ($params as $param => $value) 
                $stmt->bindValue(':', $param, $value);
            $stmt->execute();
            return $stmt;
        catch (PDOException $e) 
            throw new Exception("query failed to execute {$e->getMessage()}");

    -el query es llamado desde el home.php controller
        $config = require basePath('config/db.config.php');
        $db = new Database($config);
        $listing = $db->query("SELECT * FROM listings LIMIT 6")->fetchAll(); //gegting all
        inspect($listing);
        loadView('home');

//passing data to view
    -dentro del controlador -> loadView('home', ['listings' => $listing,]);
    - se anade un array vacio al parametro de loadView en helpers
        function loadView(string $name, $data = [])
            if (file_exists($viewPath)) 
                extract($data);  //extrallendo los datos del array
                require $viewPath; //importalo
    -en home.view.php se accede a lo enviado con <!-- <?php inspect($listings) ?> -->
        <?php foreach ($listings as $listing) : ?>
              <h2 class="text-xl font-semibold"><?= $listing['title'] ?></h2>
        <? endforeach ?>
        <a href="/listing/<?= $listing['id'] ?>

    -usando objetos
        <h2 class="text-xl font-semibold"><?= $listing['title'] ?></h2>
        <h2 class="text-xl font-semibold"><?= $listing->title ?></h2>

//REsumen
    -entramos al website (index.php) -> index.php = ve el uri y el metodo y lo pasa al routclas -> Route.php = mapea a controladores =>home.controller.php= inicia una nueva instancia con el db y hace el fetchAll, luego envia el resultado al view -> home.view.php = se accede al listado mediante un mapa

-sening query strings
    /listing?id=<?= $listing->id 
    -se agrega al route'/listings','controllers/listings/show.view.php
    -se modifica el uri en index.php para excluir query
        de $uri = $_SERVER['REQUEST_URI'];
        a $uri = parse_url($_SERVER['REQUEST_URI'], PHP_URL_PATH);
    -en el show.php controller
        -se importa el db y se crea una instancia
        -se obitne el id con $_GET['id']
        -se carga el view (show.view.php) y se manda los datos

    //namespaces controller classes router

    //folder refaactor
    folders
        -framework
            -Database
            -Router
        -App
            -controllers
            -views

    //Creating autoloader
    -will allow us to have a bunch of classes and not have to require them 
    individua. avoid require...
    -en Index.php
            //------importando ------------
            // require basePath('Framework/Database.php');
            // require basePath('Framework/Router.php');
            //-----AUTO LOADER---------------------
            spl_autoload_register(function ($class) {
                //maping file to a name
                $path = basePath('Framework/' . $class . '.php');
                if (file_exists($path)) {
                    require($path);
                }});
    --installing composer manager
        -creating composer.json
            {"name":"rick",
            "description": "Job listing application",
            "authors": [{
                "name": "Rick",
                "email": "legoric@fvd.com",}],
            "autoload": {
                "psr-4": {
                    // sepecify name spaces and folder
                    "Framework\\":"Framework/",
                    "App\\":"App/"
                }}}
    --una vez ejecutado y todo correcto. se creara una carpeta llamada Vendor
    -en index se borra todo los require y son remplazados por 
        //using composer 
        require __DIR__.'/../vendor/autoload.php'

    -creating namesapaces
        -en folder framework
            -en cada archivo agregar a "namespace Framework"
            -para usar Router.php
                1- $router = new Framework\Router();
                2 - use Framework\router;
                    $router = new Router();
            -en database como se usa pDO se tiene que importar use PDO;


//Refactor of Router class (controller methods instead of files)
    -routes
        -se modifican los index $router->get('/', 'HomeController@index');

    -Router
        - se extrae informacion del string enviado (RegisterRoute)
            //controler -> HomeController@index
            list($controller, $controllerMethod) = explode('@', $action); //[homeController,index]
            $this->routes[] = [ //agregando
                'method' => $method,
                'uri' => $uri,
                'controller' => $controller,
                'controllerMethod' => $controllerMethod
            ];
        - route() method
             //extract controller and controller method
            $controller = 'App\\Controllers\\' . $route['controller'];
            $controllerMethod = $route['controllerMethod'];
            //instatiate the controller and call the method
            $controllerInstance = new $controller();
            $controllerInstance->$controllerMethod();
            return;
        
        -al ir a la pagina / se ejecutara el HomeController constructor y luego se usara el metodo index(). esto es bueno para los middleware

//103
    -se mueve todo al homeController
        -la base de datos es conectada en el constructor del HomeController e iniciada
    - en HomeController@index se ejecuta el query para el fetchall
         $listing = $this->db->query("SELECT * FROM listings LIMIT 6")->fetchAll(); //gegting all
        // inspect($listing);
        //cargando view y enviando informacion
        loadView('home', ['listings' => $listing,]);

    -fetching from a controller function
        $id = $_GET['id'] ?? '';
        $params = [
            'id' => $id
        ];
        //llamando a db
        $listing = $this->db->query("SELECT * FROM listings WHERE id=:id", $params)->fetch();
        loadView('listings/show', ['listing' => $listing]);

104 - errorcontroler
    -se creo el controlador del error y los tipos de errores son metodos estaticos
        -esto es para no crear un objeto por cada error
    - en homeController 
        use App\Controllers\ErrorController
        ErrorController::notfound()

105 - handling route params

    -en routes.php 
        $router->get('/listing/{id},'ListingController@show')

    -en index.php
        -se borra la obtenicion del method para que se obtenga directamente en los routes
        -solo pasa uri
    -en Ruter.php en route methods
        -se obtiene el metodo enviado
        - se loopea por las rutas existentes
            -se obtienen los segmentos del uri enviado
            -se obtiene los semgentos del uri del current route

            -cuenta si el numero de segmentos es el mismo y si el metodo es el mismo
                -se lopea los segmentso del uri enviado
                    -si los segmentos del uri enviado No son lo mimso que el route a probar o si el segmento del uri enviado NO contiene {}
                        -se sale 
                    - si son lo mismo y tiene {}
                        -se checa el parametro y se extrae a una variable 
                        -se guarda el valor del paramtro enviado en un map quie contiene el nombre del parametro como key
                    - se llama al controlador
                    -se crea una variable con el metodo
                    - se crea una instancia del objeto controler
                    - se envia los parametros al metodo de la instancia
                    

108 - Validation
    - se crean funciones para validar
    - el post envie informacion y la valida. regresa si hay informacion invalida
    $router->post('/listings', 'ListingController@store');

112 -borrar
    - se le agrega un hidden input al view
        _method  value = 'delete'
    - se modifico el router para aceptar hidden inputs
        -input _method
        if ($requestMethod === "POST" && isset($_POST['_method'])) {
            //override the post method with custom method
            $requestMethod = strtoupper($_POST['_method']);
        }
        -se obitnee el id mediante el uso de los parametros enviados en la uri
        -checa si el metodo es post y si el hidden input es delete
            -si hay hidden input el metodo se sobreescribe

    -en el metodo del controlador
        -se obtiene los parametros
        - se envia un query para obtener los datos (para ver si siguen existiendo)
        - si los datos no existe mistrar pagina de que no existen 
        -si existen entonces enviar otro query pero esta ves de eliminar

113 - flashing message
    - using session superglobal
    - session_start() en index.php en public
    - en listing controller destoy()
        //using session. flash message
        $_SESSION['success_message'] = 'Listings deleted successfully';
    -en el view crear un partial error
         <?php if (isset($_SESSION['success_message'])) : ?>
            <div class="message bg-green-100 p-3 my-3">
                <?= $_SESSION['success_message'] ?>
            </div>
            <?php unset($_SESSION['success_message']); ?>
        <?php endif; ?>

114 - editing
    - create 2 routes
        - edit = shows edit from
        - update = update valuees
    $router->get('/listings/edit/{id}', "ListingController@edit");
    $router->put('/listings/{id}', 'ListingConstroller@update');
    - crear los metodos en controller
        - para el edit es lo mismo que el show pero el view es edit

115 - updating
    - en edit view agregar un hidden input de put
         <form method="POST" action="/listings/<?= $listing->id ?>">
        <input type="hidden" name="_method" value="PUT">
